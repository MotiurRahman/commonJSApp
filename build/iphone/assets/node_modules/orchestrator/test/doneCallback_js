

'use strict';

var Orchestrator=require('../'),
Q=require('q'),
fs=require('fs'),
should=require('should');
require('mocha'),

describe('orchestrator',function(){
describe('stop() callback',function(){

it('should have empty error on succeeding tasks',function(done){
var orchestrator,a;


orchestrator=new Orchestrator,
a=0,
orchestrator.add('test',function(){
++a;
}),


orchestrator.start('test',function(err){

a.should.equal(1),
should.not.exist(err),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on fail by callback tasks',function(done){
var orchestrator,a,expectedErr={message:'the error'};


orchestrator=new Orchestrator,
a=0,
orchestrator.add('test',function(cb){
++a,
cb(expectedErr);
}),


orchestrator.start('test',function(err){

a.should.equal(1),
should.exist(err),
should.deepEqual(err,expectedErr),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on sync throw',function(done){
var orchestrator,a,errMess='the error message';


orchestrator=new Orchestrator,
a=0,
orchestrator.add('test',function(){

throw++a,new Error(errMess);
}),


orchestrator.start('test',function(err){

a.should.equal(1),
should.exist(err),
err.message.should.equal(errMess),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on promise rejected',function(done){
var orchestrator,a,expectedErr='the error message';


orchestrator=new Orchestrator,
a=0,
orchestrator.add('test',function(){
var deferred=Q.defer();




return setTimeout(function(){++a,deferred.reject(expectedErr)},1),deferred.promise;
}),


orchestrator.start('test',function(actualErr){

a.should.equal(1),
should.exist(actualErr),
actualErr.should.equal(expectedErr),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on stream error',function(done){
var orchestrator;


orchestrator=new Orchestrator,
orchestrator.add('test',function(){
return fs.createReadStream('./index.js').
pipe(fs.createWriteStream('./something/that/does/not/exist'));
}),


orchestrator.start('test',function(actualErr){

should.exist(actualErr),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on missing task',function(done){
var orchestrator,name,a,expectedErr;


name='test',
a=0,
orchestrator=new Orchestrator,



orchestrator.on('task_not_found',function(e){
a++,
e.task.should.equal(name),
e.message.should.match(/not defined/i,e.message+' should include not defined'),
should.exist(e.err),
expectedErr=e.err;
}),
orchestrator.start(name,function(actualErr){

a.should.equal(1),
should.exist(actualErr),
actualErr.should.equal(expectedErr),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error on recursive tasks',function(done){
var orchestrator,name,a,expectedErr;


name='test',
a=0,
orchestrator=new Orchestrator,
orchestrator.add(name,[name]),


orchestrator.on('task_recursion',function(e){
a++,
e.recursiveTasks.length.should.equal(2),
e.recursiveTasks[0].should.equal(name),
e.recursiveTasks[1].should.equal(name),
e.message.should.match(/recursive/i,e.message+' should include recursive'),
should.exist(e.err),
expectedErr=e.err;
}),
orchestrator.start(name,function(actualErr){

a.should.equal(1),
should.exist(actualErr),
actualErr.should.equal(expectedErr),
orchestrator.isRunning.should.equal(!1),
done();
});
}),

it('should have error when calling callback too many times',function(done){
var orchestrator,a,timeout=30;


orchestrator=new Orchestrator,
a=0,
orchestrator.add('test',function(cb){
cb(null),
cb(null);
}),


orchestrator.start('test',function(err){


0===a?

should.not.exist(err):

1===a?(

should.exist(err),
err.message.indexOf('too many times').should.be.above(-1)):


done('finished too many times');

a++;
}),
setTimeout(function(){
a.should.equal(2),
done();
},timeout);
});

});
});